Data Operations
 how-to
Documents
A document refers to an entry in the database (other databases may refer to the same concept as a row). A document has an ID (primary key in other databases), which is unique to the document and by which it can be located. The document also has a value which contains the actual application data. See the concept guide to Documents for a deeper dive into documents in the Couchbase Data Platform. Or read on, for a hands-on introduction to working with documents from the Node.js SDK.

CRUD Operations
The core interface to Couchbase Server is simple KV operations on full documents. Make sure you’re familiar with the basics of authorization and connecting to a Cluster from the Start Using the SDK section. We’re going to expand on the short Upsert example we used there, adding options as we move through the various CRUD operations. Here is the Insert operation at its simplest:

Insert
javascript
View
Copy
const result = await collection.insert(key, document);
Options may be added to operations:

Insert (with options)
javascript
View
Copy
const result = await collection.insert(key, document,
    { timeout: 10000 } // 10 seconds
);
Setting a Compare and Swap (CAS) value is a form of optimistic locking - dealt with in depth in the CAS page. Here we just note that the CAS is a value representing the current state of an item; each time the item is modified, its CAS changes. The CAS value is returned as part of a document’s metadata whenever a document is accessed.

timeout is an optional parameter which is represented in milliseconds. Timeout sets the timeout value for the operation. We will add to these options for the Replace example:

javascript
View
Copy
const result = await collection.replace(key,
    document,
    { cas: cas, expiry: 60, timeout: 5000 }
);
Expiration sets an explicit time to live (TTL) for a document. We’ll discuss modifying Expiration in more details below. For a discussion of item (Document) vs Bucket expiration, see the Expiration Overview page.

Durability
javascript
View
Copy
let result = await collection.upsert(key, document,
    {
        expiry: 60,
        persist_to: 1,
        replicate_to: 0, // cannot replicate on single node
        timeout: 5000
    }
);
Here, we have added Durability options, namely persistTo and replicateTo. In Couchbase Server releases before 6.5, Durability was set with these two options — see the 6.0 Durability documentation — covering how many replicas the operation must be propagated to and how many persisted copies of the modified record must exist. If a version of Couchbase Server lower than 6.5 is being used then the application can fall-back to this 'client verified' durability.

If 6.5 or above is being used, you can take advantage of the Durable Write feature, in which Couchbase Server will only return success to the SDK after the requested replication level has been achieved. The three replication levels are:

Majority - The server will ensure that the change is available in memory on the majority of configured replicas.

MajorityAndPersistToActive - Majority level, plus persisted to disk on the active node.

PersistToMajority - Majority level, plus persisted to disk on the majority of configured replicas.

The options are in increasing levels of safety. Note that nothing comes for free - for a given node, waiting for writes to storage is considerably slower than waiting for it to be available in-memory. These trade offs, as well as which settings may be tuned, are discussed in the durability page.

The following example demonstrates using the newer durability features available in Couchbase server 6.5 onwards.

javascript
View
Copy
let result = await collection.upsert(key, document,
    {
        expiry: 60,  // 60 seconds,
        durabilityLevel: couchbase.DurabilityLevel.None, // Majority etc.
        timeout: 5000
    } // 5 seconds
);
To stress, durability is a useful feature but should not be the default for most applications, as there is a performance consideration, and the default level of safety provided by Couchbase will be reasonable for the majority of situations.

Sub-Document Operations
All of these operations involve fetching the complete document from the Cluster. Where the number of operations or other circumstances make bandwidth a significant issue, the SDK can work on just a specific path of the document with Sub-Document Operations.

Retrieving full documents
Using the get() method with the document key can be done in a similar fashion to the other operations:

javascript
View
Copy
const result = await collection.get(key);
document = result.value;
Timeout can also be set - as in the earlier Insert example:

Get (with options)
javascript
View
Copy
const result = await collection.get(key, { timeout: 1000 });
document = result.value;
Removing
When removing a document, you will have the same concern for durability as with any additive modification to the Bucket:

Remove (with options)
javascript
View
Copy
const result = await collection.remove(key,
    {
        cas: cas,
        persist_to: 0,  // non-zero gives "not implemented"
        replicate_to: 0, // cannot replicate on single node
        timeout: 5000
    }
);
Expiration / TTL
By default, Couchbase documents do not expire, but transient or temporary data may be needed for user sessions, caches, or other temporary documents. Using touch(), you can set expiration values on documents to handle transient data:

javascript
View
Copy
const result = await collection.touch(key, 100); // 100 seconds
A network timeout can be set with the options, in the same fashion as earlier examples on this page:

javascript
View
Copy
const result = await collection.touch(key, 100,  // 100 seconds
    { timeout: 5000 } // 5 seconds
);
If the absolute value of the expiry is less than 30 days (such as 60 * 60 * 24 * 30), it is considered an offset. If the value is greater, it is considered an absolute time stamp. For more on expiration see the expiration section of our documents discussion doc.
Atomic Counters
The value of a document can be increased or decreased atomically using binary().increment() and binary().decrement().

Increment & Decrement are considered part of the ‘binary’ API and as such may still be subject to change
Increment
javascript
View
Copy
// increment binary value by 1
const result = await collection.binary().increment(binValKey, 1);
Increment (with options)
javascript
View
Copy
// increment binary value by 1, if binValKey doesn’t exist, seed it at 1000
const result = await collection.binary().increment(binValKey, 1, {
    initial: 1000,
    timeout: 5000
});
Decrement
javascript
View
Copy
// decrement binary value by 1
const result = await collection.binary().decrement(binValKey, 1);
Decrement (with options)
javascript
View
Copy
// decrement binary value by 1, if binValKey doesn’t exist, seed it at 1000
const result = await collection.binary().decrement(binValKey, 1,
    {
        initial: 1000,
        timeout: 5000
    },
);
Setting the document expiry time only works when a document is created, and it is not possible to update the expiry time of an existing counter document with the Increment method — to do this during an increment, use with the Touch() method.
Atomicity Across Data Centers
If you are using Cross Data Center Replication (XDCR), be sure to avoid modifying the same counter in more than one datacenter. If the same counter is modified in multiple datacenters between replications, the counter will no longer be atomic, and its value can change in unspecified ways.

A counter must be incremented or decremented by only a single datacenter. Each datacenter must have its own set of counters that it uses — a possible implementation would be including a datacenter name in the counter document ID.

KV Range Scan
A range scan gives you documents from a collection, even if you don’t know the document IDs. This feature requires Couchbase Server 7.6 or newer.

KV range scan is suitable for use cases that require relatively low concurrency and tolerate relatively high latency. If your application does many scans at once, or requires low latency results, we recommend using SQL++ (with a primary index on the collection) instead of KV range scan.
Range scan
Here’s an example of a KV range scan that gets all documents in a collection:

KV Range Scan for all documents in a collection
javascript
View
Copy
const { RangeScan } = require('couchbase/dist/rangeScan')

result = await collection.scan(new RangeScan()) 
result.forEach((r) => {
  console.log(`Found result, ID=${r.id}, content=`, r.content)
})
The RangeScan class has two optional parameters: start and end. If you omit them like in this example, you’ll get all documents in the collection. These parameters are for advanced use cases; you probably won’t need to specify them. Instead, it’s more common to use the "prefix" scan type shown in the next example.
Prefix scan
KV range scan can also give you all documents whose IDs start with the same prefix. Imagine you have a collection where documents are named like this: <username>::<uuid>. In other words, the document ID starts with the name of the user associated with the document, followed by a delimiter, and then a UUID. If you use this document naming scheme, you can use a prefix range scan to get all documents associated with a user. For example, to get all documents associated with user "alice", you would write:

KV Range Scan for all documents in a collection whose IDs start with alice::
javascript
View
Copy
const { PrefixScan } = require('couchbase/dist/rangeScan')

result = await collection.scan(new PrefixScan('alice::'))
result.forEach((r) => {
  console.log(`Found result, ID=${r.id}, content=`, r.content)
})
Sample scan
If you want to get random documents from a collection, use a sample scan.

KV Range Scan for 100 random documents
javascript
View
Copy
const { SamplingScan } = require('couchbase/dist/rangeScan')

result = await collection.scan(new SamplingScan(100))
result.forEach((r) => {
  console.log(`Found result, ID=${r.id}, content=`, r.content)
})
Get IDs instead of full documents
If you only want the document IDs, set the idsOnly field of ScanOptions to true, like this:

KV Range Scan for all document IDs in a collection
javascript
View
Copy
result = await collection.scan(new RangeScan(), {idsOnly: true})
result.forEach((r) => {
  console.log(`Found result, ID=${r.id}`)
})
Scoped KV Operations
It is possible to perform scoped key value operations on named Collections with Couchbase Server release, 7.0.

Here is an example showing an upsert in the users collection, which lives in the travel-sample.tenant_agent_00 keyspace:

javascript
Copy
const sampleOptions = { username: 'Administrator', password: 'password' };
const sampleCluster = new couchbase.Cluster("localhost", sampleOptions);
const sampleBucket = sampleCluster.bucket("travel-sample");
const sampleScope = sampleBucket.scope("tenant_agent_00");
sampleColl = sampleScope.collection("users");

[data-source-url=https://github.com/couchbase/docs-sdk-nodejs/blob/32ab4a411f71ceb8db390abd0574461486d234ff/modules/devguide/examples/nodejs/kv-operations.js#L514-L515]
let collDocument = { name: 'John Doe', preferred_email: 'johndoe111@test123.test' };
result = await sampleColl.upsert(user, collDocument);


Query
 how-to
You can query for documents in Couchbase using the SQL++ query language, a language based on SQL, but designed for structured and flexible JSON documents. Querying can solve typical programming tasks such as finding a user profile by email address, Facebook login, or user ID.
Getting Started
Our query service uses SQL++ (formerly N1QL), which will be fairly familiar to anyone who’s used any dialect of SQL. Additional resources for learning about SQL++ are listed at the bottom of the page.

Before you get started you may wish to check out the SQL++ intro page, or just dive in with a query against our travel-sample data set. Also, building indexes is covered in more detail on the Query concept page.

After familiarizing yourself with the basics on how the SQL++ query language works and how to query it from the UI you can use it from the Node.js SDK.

Queries & Placeholders
Placeholders allow you to specify variable constraints for an otherwise constant query. There are two variants of placeholders: positional and named parameters. Positional parameters use an ordinal placeholder for substitution and named parameters use variables. A named or positional parameter is a placeholder for a value in the WHERE, LIMIT, or OFFSET clause of a query. Note that both parameters and options are optional.

Positional parameter example:
javascript
View
Copy
async function queryPlaceholders() {
  const query = `
  SELECT airportname, city FROM \`travel-sample\`.inventory.airport
  WHERE city=$1
  `;
  const options = { parameters: ['San Jose'] }

  try {
    let result = await cluster.query(query, options)
    console.log("Result:", result)
    return result
  } catch (error) {
    console.error('Query failed: ', error)
  }
}
Named parameter example:
javascript
View
Copy
async function queryNamed() {
  const query = `
    SELECT airportname, city FROM \`travel-sample\`.inventory.airport
    WHERE city=$CITY;
  `
  const options = { parameters: { CITY: 'Reno' } }

  try {
    let result = await cluster.query(query, options)
    console.log("Result:", result)
    return result
  } catch (error) {
    console.error('Query failed: ', error)
  }
}
Handling Results
Most queries return more than one result, and you want to iterate over the results:

javascript
View
Copy
async function queryResults() {
  const query = `
  SELECT airportname, city FROM \`travel-sample\`.inventory.airport
  WHERE tz LIKE '%Los_Angeles'
    AND airportname LIKE '%Intl';
  `
  try {
    let results = await cluster.query(query);
    results.rows.forEach((row) => {
      console.log('Query row: ', row)
    })
    return results
  } catch (error) {
    console.error('Query failed: ', error)
  }
}
CAS and SQL++
If you are performing an operation with SQL++ that requires CAS to be used, in combination with using CAS from regular KV operations for example, then you need to be aware of the CAS type. CAS is stored as a 64-bit integer, which cannot be represented safely in javaScript — thus you must convert to a string:

javascript
Copy
  const GET_IDS = `
    SELECT  META().id AS recordId
          , TOSTRING(META().cas) AS cas
          , id
    FROM cdb
    WHERE type = 'profile'
    LIMIT $count
    `;
Querying the default Scope
When working with earlier versions (before the Developer Preview in 6.5), or with other server versions, the defaultcollection is used from the SDK, by simply addressing the Bucket itself.

javascript
View
Copy
async function queryNamed() {
  const query = `
    SELECT airportname, city FROM \`travel-sample\` 
    WHERE type=$TYPE 
      AND city=$CITY;
  `
  const options = { parameters: { TYPE: 'airport', CITY: 'Reno' } }

  try {
    let result = await cluster.query(query, options)
    console.log("Result:", result)
    return result
  } catch (error) {
    console.error('Query failed: ', error)
  }
}

Search
 how-to
You can use the Full Text Search service (FTS) to create queryable full-text indexes in Couchbase Server.
FTS allows you to create, manage, and query full-text indexes on JSON documents stored in Couchbase buckets.

It uses natural language processing for querying documents, provides relevance scoring on the results of your queries, and has fast indexes for querying a wide range of possible text searches.

Supported query types include simple queries like Match and Term queries; range queries like Date Range and Numeric Range; and compound queries for conjunctions, disjunctions, and/or boolean queries.

The Node.js SDK exposes an API for performing FTS queries which abstracts some of the complexity of using the underlying REST API.

The Full Text Search service also supports vector search from Couchbase Server 7.6 onwards.

There are two APIs for querying search: cluster.searchQuery(), and cluster.search(). Both are also available at the Scope level.

The former API supports FTS queries (SearchQuery), while the latter additionally supports the VectorSearch added in 7.6. Most of this documentation will focus on the former API, as the latter is in @Stability.Volatile status.

Examples
Search queries are executed at the cluster level (not bucket or collection). All examples below will console log our returned documents along with their metadata and rows, each returned document has an index, id, score and sort value.

Match
Using the travel-sample Sample Bucket, we define an FTS SearchQuery using the match() method to search for the specified term: "five-star".

javascript
View
Copy
  async function ftsMatchWord(term) {
    return await cluster.searchQuery(
      'index-hotel-description',
      couchbase.SearchQuery.match(term),
      { limit: 5 }
    )
  }

  var result = await ftsMatchWord('five-star')
  console.log('RESULT:', result)
Match Phrase
An FTS SearchQuery using the matchPhrase() method to find a specified phrase: "10-minute walk from the".

javascript
View
Copy
  async function ftsMatchPhrase(phrase) {
    return await cluster.searchQuery(
      'index-hotel-description',
      couchbase.SearchQuery.matchPhrase(phrase),
      { limit: 10 }
    )
  }

  result = await ftsMatchPhrase('10-minute walk from the')
  console.log('RESULT:', result)
When searching for a phrase we get some additional benefits outside of the match() method. The match phrase query for "10-minute walk from the" will produce the following hits from our travel-sample dataset:

bash
Copy
hits:
  hotel_11331: "10-minute walk from village"
  hotel_15915: "10 minute walk from Echo Arena"
  hotel_3606: "10 minute walk to the centre"
  hotel_28259: "10 minute walk to the coastal path"
If you run this code, notice that we matched "10-minute" with three additional hits on "10 minute" (without the dash). So, we get some of the same matches on variations of that term just as we would with a regular match() method search, however; notice that "walk from the" hits on several variations of this phrase: "walk from" (where "the" was removed) and "walk to the" (where "from" was removed). This is specific to searching phrases and helps provide us with various matches relevant to our search.

Date Range
Here we define an FTS SearchQuery that uses the dateRange() method to search for hotels where the updated field (datetime) falls within a specified date range.

javascript
View
Copy
    async function ftsHotelByDateRange(startDate, endDate) {
      const upsertResult = await collection.upsert('hotel_fts_123', {
        name: 'HotelFTS',
        updated: new Date('2010-11-10 18:33:50 +0300'),
        description: 'a fancy hotel',
        type: 'hotel',
      })

      return await cluster.searchQuery(
        'index-hotel-description',
        couchbase.SearchQuery.dateRange().start(startDate).end(endDate),
        {
          limit: 5,
        }
      )
    }

    result = await ftsHotelByDateRange('2010-11-10', '2010-11-20')
    console.log('RESULT:', result)
Conjunction
A query satisfying multiple child queries. The example below will only return two documents hitting on the term "five-star" and the phrase "luxury hotel" while no other documents match both criteria.

javascript
View
Copy
  async function ftsConjunction() {
    return await cluster.searchQuery(
      'index-hotel-description',
      couchbase.SearchQuery.conjuncts(
        couchbase.SearchQuery.match('five-star'),
        couchbase.SearchQuery.matchPhrase('luxury hotel')
      )
    )
  }

  var result = await ftsConjunction()
  console.log('RESULT:', result)
Note: Our match for "five-star" was not exact, but still produced a result because a similar term was found "Five star", we could have potentially matched "5 star" or the word "five". When you work with any full-text search the number of hits you get and their score are variable.

Disjunction
A query satisfying (by default) one query or another. If a conjunction query can be thought of like using an AND operator, a disjunction would be like using an OR operator. The example below will return seven documents hitting on the term "Louvre" and five hits on the term "Eiffel" returning a total of 12 rows together as part of a disjunction query.

javascript
View
Copy
  async function ftsDisjunction() {
    return await cluster.searchQuery(
      'index-hotel-description',
      couchbase.SearchQuery.disjuncts(
        couchbase.SearchQuery.match('Louvre'),
        couchbase.SearchQuery.match('Eiffel')
      ),
      {
        facets: {
          Descriptions: new couchbase.TermSearchFacet('description', 5),
        },
        limit: 12,
      }
    )
  }

  result = await ftsDisjunction()
  console.log('RESULT:', result)
Working with Results
As with all query result types in the Node.js SDK, the search query results object contains two properties. The hits reflecting the documents that matched your query, emitted as rows. Along with the metadata available in the meta property.

Metadata holds additional information not directly related to your query, such as success total hits and how long the query took to execute in the cluster.

Iterating over Hits
javascript
View
Copy
result.rows.forEach((hit, index) => {
  const docId = hit.id
  const score = hit.score
  const resultNum = index + 1
  console.log(`Result #${resultNum} ID: ${docId} Score: ${score}`)
})
Facets
javascript
View
Copy
var facets = result.meta.facets
console.log('Descriptions facet:', facets.Descriptions)
Scoped vs Global Indexes
The FTS APIs exist at both the Cluster and Scope levels.

This is because FTS supports, as of Couchbase Server 7.6, a new form of "scoped index" in addition to the traditional "global index".

It’s important to use the Cluster.searchQuery() / Cluster.search() for global indexes, and Scope.search() for scoped indexes.

Vector Search
As of Couchbase Server 7.6, the FTS service supports vector search in additional to traditional full text search queries.

Examples
Single vector query
In this first example we are performing a single vector query:

javascript
View
Copy
let request = couchbase.SearchRequest.create(
  couchbase.VectorSearch.fromVectorQuery(
    couchbase.VectorQuery.create('vector_field', queryVector)
  )
)
result = await scope.search('vector-index', request)
Let’s break this down. We create a SearchRequest, which can contain a traditional FTS query SearchQuery and/or the new VectorSearch. Here we are just using the latter.

The VectorSearch allows us to perform one or more VectorQuery s.

The VectorQuery itself takes the name of the document field that contains embedded vectors ("vector_field" here), plus actual vector query in the form of a float[].

(Note that Couchbase itself is not involved in generating the vectors, and these will come from an external source such as an embeddings API.)

Finally we execute the SearchRequest against the FTS index "vector-index", which has previously been setup to vector index the "vector_field" field.

This happens to be a scoped index so we are using scope.search(). If it was a global index we would use cluster.search() instead - see Scoped vs Global Indexes.

It returns the same SearchResult detailed earlier.

Multiple vector queries
You can run multiple vector queries together:

javascript
View
Copy
request = couchbase.SearchRequest.create(
  couchbase.VectorSearch([
    couchbase.VectorQuery.create('vector_field', queryVector)
      .numCandidates(2)
      .boost(0.3),
    couchbase.VectorQuery.create('vector_field', anotherQueryVector)
      .numCandidates(5)
      .boost(0.7),
  ])
)
result = await scope.search('vector-index', request)
How the results are combined (ANDed or ORed) can be controlled with vectorQueryCombination in VectorSearchOptions.

Combining FTS and vector queries
You can combine a traditional FTS query with vector queries:

javascript
View
Copy
request = couchbase.SearchRequest.create(
  couchbase.SearchQuery.matchAll()
).withVectorSearch(
  couchbase.VectorSearch.fromVectorQuery(
    couchbase.VectorQuery.create('vector_field', queryVector)
  )
)
result = await scope.search('vector-and-fts-index', request)
How the results are combined (ANDed or ORed) can be controlled with vectorQueryCombination in VectorSearchOptions.

FTS queries
And note that traditional FTS queries, without vector search, are also supported with the new cluster.search() / scope.search() APIs:

javascript
View
Copy
request = couchbase.SearchRequest.create(couchbase.SearchQuery.matchAll())
result = await scope.search('index-hotel-description', request)
The SearchQuery is created in the same way as detailed earlier.

Scan Consistency and ConsistentWith
By default, all Search queries will return the data from whatever is in the index at the time of query. These semantics can be tuned if needed so that the hits returned include the most recently performed mutations, at the cost of slightly higher latency since the index needs to be updated first.

There are two ways to control consistency: either by supplying a custom SearchScanConsistency or using consistentWith. At the moment the cluster only supports consistentWith, which is why you only see SearchScanConsistency.NotBounded in the enum which is the default setting. The way to make sure that recently written documents show up in the search works as follows (commonly referred to "read your own writes" — RYOW):

Scan consistency example:
javascript
View
Copy
result = await cluster.searchQuery(
  'index-hotel-description',
  couchbase.SearchQuery.match('swanky'),
  { consistency: couchbase.SearchScanConsistency.NotBounded }
)
ConsistentWith consistency example:
javascript
View
Copy
    async function ftsHotelByDateRange(startDate, endDate) {
      const upsertResult = await collection.upsert('hotel_fts_123', {
        name: 'HotelFTS',
        updated: new Date('2010-11-10 18:33:50 +0300'),
        description: 'a fancy hotel',
        type: 'hotel',
      })

      const mutationState = new couchbase.MutationState(upsertResult.token)
      return await cluster.searchQuery(
        'index-hotel-description',
        couchbase.SearchQuery.dateRange().start(startDate).end(endDate),
        {
          limit: 5,
          consistentWith: mutationState,
        }
      )
    }

    result = await ftsHotelByDateRange('2010-11-10', '2010-11-20')
    console.log('RESULT:', result)